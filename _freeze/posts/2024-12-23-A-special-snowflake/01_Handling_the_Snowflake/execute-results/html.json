{
  "hash": "6b835925b4261be80f9cf618f50d6b0a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: How to handle a very special snowflake\ndate: '2024-12-23'\nimage: ./snowflake_logo.png\nexecute:\n  echo: true\n  warning: false\n  message: false\ncode-tools: false\nformat:\n  html:\n    code-fold: false\n    code-copy: true\n    toc: true\n    toc-depth: 2\n    toc-title: Contents\ncomments:\n  hypothesis:\n    theme: clean\n---\n\n![](./snowflake_logo.png){.float-right}\n\n::: {.justify}\nI know—sketchy title. But bear with me for a second. Today, I want to dive into the world of data warehousing and explain why Snowflake, as a data platform, stands out as the \"special snowflake\" in this space. So...\n\n## What Is Snowflake?\nSnowflake is a cloud-native data platform that provides a fully managed service for data warehousing, data lakes, and data analytics. Unlike traditional data warehouses, which often require heavy infrastructure management and scaling considerations, Snowflake was built from the ground up to leverage the power and flexibility of the cloud.\n\nBut what exactly makes Snowflake so special? Let's break it down.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n### 1. Separation of Compute and Storage\nTraditional data warehouses often couple storage (where the data is saved) with compute resources (how the data is processed). This means if your queries suddenly require more processing power, you might have to scale up everything, including your storage capacity, even if it isn't needed. Snowflake solves this by decoupling compute from storage.\n\nStorage: Your data is stored in scalable cloud storage (e.g., Amazon S3, Azure Blob Storage, or Google Cloud Storage). You only pay for the storage you use.\nCompute: Compute resources are handled via \"virtual warehouses.\" These can scale up or down independently of the storage layer, allowing you to allocate resources based on your query load.\nThis separation means you can handle huge amounts of data without bottlenecking your compute resources—or breaking the bank.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n### 2. Multi-Cloud Flexibility\nSnowflake is designed to run on multiple cloud providers, including AWS, Azure, and Google Cloud. This multi-cloud capability ensures you’re not locked into a single cloud provider. You can choose the one that best aligns with your organization's needs—or even operate across clouds for redundancy and performance optimization.\n\nFor example:\n- You might store your data in AWS for its storage cost benefits.\n- You might analyze your data in Google Cloud to take advantage of specialized ML tools.\n- Snowflake abstracts the complexity of managing these environments and provides a unified experience.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n### 3. Automatic Scalability and Elasticity\nSnowflake can scale elastically to meet your demands. If you're running a massive data query, you can temporarily scale up your compute resources and scale them back down when the query completes. This auto-scaling happens on the fly, ensuring high performance even under heavy workloads.\n\nFor businesses, this translates to cost efficiency and operational flexibility:\n- No need to maintain oversized infrastructure for peak loads.\n- Pay only for the compute resources you use, when you use them.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n### 4. Zero Copy Cloning\nOne of Snowflake's most innovative features is its \"zero-copy cloning.\" This allows you to create a copy of a database without duplicating the underlying data. Imagine needing to run analytics on production data but not wanting to interfere with live operations. With zero-copy cloning, you can spin up a clone of your database in seconds, run your queries, and discard it—all without consuming additional storage.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n### 5. Support for Semi-Structured and Structured Data\nUnlike traditional databases that struggle with semi-structured data formats like JSON, Avro, or Parquet, Snowflake handles them seamlessly. Using its \"VARIANT\" data type, Snowflake can ingest semi-structured data and make it queryable with SQL—no need for complex transformations.\n\nThis makes it ideal for modern businesses that deal with mixed data formats, such as:\n- Log data from web servers (semi-structured)\n- Transactional data from databases (structured)\n:::\n\nSnowflake’s design philosophy—decoupling compute and storage, supporting multi-cloud environments, and enabling seamless scalability—sets it apart from traditional data warehouses. Add in features like zero-copy cloning, seamless handling of semi-structured data, and real-time data sharing, and you have a platform that’s not only efficient but also innovative. So, next time someone asks you why Snowflake is so special, you’ll know exactly what to say. Alright, alright...but how do we actually handle the snowflake (upload/download files) using our favorite programming languange python? This is what I will show you today using a simple wrapper class. \n\n## Handle the snowflake from python\n\n::: {#e212733a .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport json\nimport pandas as pd\nimport snowflake.connector\n\nclass SnowflakeHandler:\n    \"\"\"\n    A wrapper class to upload local CSV files to a Snowflake stage, load the data into a table,\n    and download data from a Snowflake table to a local file.\n    \"\"\"\n    def __init__(self, local_file_path=None, table_name=None, stage_name=\"@~\", config_path=\"config.json\"):\n        \"\"\"\n        Initialize the SnowflakeHandler with file paths, table name, and connection details.\n        \n        Args:\n            local_file_path (str): Local path to the CSV file for upload/download.\n            table_name (str): Target Snowflake table name.\n            stage_name (str): Snowflake stage name. Defaults to '@~'.\n            config_path (str): Path to the JSON configuration file with Snowflake credentials.\n        \"\"\"\n        self.local_file_path = local_file_path\n        self.table_name = table_name\n        self.stage_name = stage_name\n        self.snowflake_stage_file = os.path.basename(local_file_path) if local_file_path else None\n        \n        # Load Snowflake connection parameters from the config file\n        with open(config_path, 'r') as f:\n            self.conn_params = json.load(f)\n        \n        # Connect to Snowflake\n        self.conn = snowflake.connector.connect(**self.conn_params)\n        self.cur = self.conn.cursor()\n\n    def map_dtype_to_snowflake(self, dtype):\n        \"\"\"\n        Map pandas data types to Snowflake SQL types.\n        \n        Args:\n            dtype (dtype): Pandas data type.\n        \n        Returns:\n            str: Corresponding Snowflake SQL type.\n        \"\"\"\n        if pd.api.types.is_integer_dtype(dtype):\n            return \"INTEGER\"\n        elif pd.api.types.is_float_dtype(dtype):\n            return \"FLOAT\"\n        elif pd.api.types.is_bool_dtype(dtype):\n            return \"BOOLEAN\"\n        elif pd.api.types.is_datetime64_any_dtype(dtype):\n            return \"TIMESTAMP\"\n        else:\n            return \"STRING\"\n\n    def generate_create_table_command(self, df):\n        \"\"\"\n        Generate a CREATE TABLE SQL statement based on a DataFrame's schema.\n        \n        Args:\n            df (pd.DataFrame): DataFrame for inferring table schema.\n        \n        Returns:\n            str: SQL command to create the table.\n        \"\"\"\n        column_definitions = []\n        for col in df.columns:\n            col_type = self.map_dtype_to_snowflake(df[col].dtype)\n            column_definitions.append(f'\"{col}\" {col_type}')\n        column_definitions_str = \",\\n    \".join(column_definitions)\n        \n        return f\"\"\"\n        CREATE OR REPLACE TABLE {self.table_name} (\n            {column_definitions_str}\n        );\n        \"\"\"\n\n    def upload_file_to_stage(self):\n        \"\"\"\n        Upload the local CSV file to the Snowflake stage.\n        \"\"\"\n        put_command = f\"PUT 'file://{self.local_file_path}' {self.stage_name}/{self.snowflake_stage_file} AUTO_COMPRESS=FALSE\"\n        self.cur.execute(put_command)\n        print(f\"File '{self.snowflake_stage_file}' uploaded to Snowflake stage '{self.stage_name}'.\")\n\n    def load_data_into_table(self):\n        \"\"\"\n        Copy the staged file into the Snowflake table.\n        \"\"\"\n        copy_command = f\"\"\"\n        COPY INTO {self.table_name}\n        FROM {self.stage_name}/{self.snowflake_stage_file}\n        FILE_FORMAT = (TYPE = 'CSV' FIELD_OPTIONALLY_ENCLOSED_BY = '\"' SKIP_HEADER = 1)\n        \"\"\"\n        self.cur.execute(copy_command)\n        print(f\"Data from '{self.snowflake_stage_file}' successfully loaded into table '{self.table_name}'.\")\n\n    def download_table(self):\n        \"\"\"\n        Download data from a Snowflake table and save it as a local CSV file.\n        \"\"\"\n        query = f\"SELECT * FROM {self.table_name}\"\n        self.cur.execute(query)\n        \n        # Fetch all rows and column names\n        data = self.cur.fetchall()\n        column_names = [desc[0] for desc in self.cur.description]\n        \n        # Save to CSV using pandas\n        df = pd.DataFrame(data, columns=column_names)\n        df.to_csv(self.local_file_path, index=False)\n        print(f\"Data from table '{self.table_name}' successfully downloaded to '{self.local_file_path}'.\")\n\n    def upload_table(self):\n        \"\"\"\n        Full process: Upload file, generate table schema, create table, and load data.\n        \"\"\"\n        # Read the CSV file to infer schema\n        df = pd.read_csv(self.local_file_path)\n        \n        # Step 1: Upload file to stage\n        self.upload_file_to_stage()\n        \n        # Step 2: Generate and execute CREATE TABLE command\n        create_table_sql = self.generate_create_table_command(df)\n        self.cur.execute(create_table_sql)\n        print(f\"Table '{self.table_name}' created successfully.\")\n        \n        # Step 3: Load data into table\n        self.load_data_into_table()\n\n    def close_connection(self):\n        \"\"\"\n        Close the Snowflake connection.\n        \"\"\"\n        self.cur.close()\n        self.conn.close()\n        print(\"Snowflake connection closed.\")\n```\n:::\n\n\nNow we can upload or download data from the snowflake however we want. Bear in mind that we currently only support upload of csv files. Similarly, downloading tables from the cloud will save them as csv files. Given that we can also upload semi-structured data, I'd like to see whether we can also upload parquet or feather files, which would drastically enhance the usability. \n\n::: {#312bdee3 .cell execution_count=2}\n``` {.python .cell-code}\n# Parameters for file upload\nlocal_csv_path = \"/Users/adaml9/Private/kaggle/playground-series/s4e11/train.csv\" \nconfig_path = \"/Users/adaml9/Private/snowflake/upload/config.json\"\nstage_name = \"@~\"\ntable_name = \"TRAIN\"\n\n# Initialize and execute\nhandler = SnowflakeHandler(\n        local_file_path=local_csv_path,\n        table_name=table_name,\n        stage_name=stage_name,\n        config_path=config_path\n    )\nhandler.upload_table()\nhandler.close_connection()\n```\n:::\n\n\n::: {#634844cd .cell execution_count=3}\n``` {.python .cell-code}\n# Parameters for file upload\nlocal_csv_path = \"/Users/adaml9/Private/kaggle/playground-series/s4e11/train2.csv\" \nconfig_path = \"/Users/adaml9/Private/snowflake/upload/config.json\"\nstage_name = \"@~\"\ntable_name = \"TRAIN\"\n\n# Initialize and execute\nhandler = SnowflakeHandler(\n        local_file_path=local_csv_path,\n        table_name=table_name,\n        stage_name=stage_name,\n        config_path=config_path\n    )\nhandler.download_table()\nhandler.close_connection()\n```\n:::\n\n\n",
    "supporting": [
      "01_Handling_the_Snowflake_files"
    ],
    "filters": [],
    "includes": {}
  }
}